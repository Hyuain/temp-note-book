# CPU

简单来讲，CPU 由寄存器、控制器、运算器和时钟组成（也可以认为时钟位于 CPU 的外部）

## 寄存器

程序是把寄存器作为对象来描述的，寄存器可以用于存放 **指令** 或者 **数据**，通过地址将这，其中 **数据** 又分为 “用于运算的值” 和 “表示内存地址的值”，这又对应了多种不同的寄存器

### 程序计数器

程序计数器决定程序的流程，存的实际上是当前执行的指令的地址

#### 顺序执行

由于指令可能占据多个内存地址，每次执行时程序计数器的值只需要增加与指令长度相当的数值就可以了

#### 条件分支和循环

使用跳转指令（jump）可以让程序计数器的值设定为任意值

### 函数的调用

- 函数在调用（call）的时候实际上就是将程序计数器的值设定为函数所在的地址，执行完成之后再跳回（return）到调用原点的地址
  
- call 指令会把调用函数后需要执行的命令地址存在 “栈” 内
  
- return 指令会把保存在 “栈” 中的地址再设定回程序计数器中

### 标志寄存器

在进行运算的时候，标志寄存器负责用标志的形式存储计算结果，这些计算结果在执行判断的时候可以用上，比如对于32位的寄存器，他的第 0、1、2 位为 1 时分别表示“运算结果为正、运算结果为 0 、运算结果为负”

在 CPU 中的大小比较实际上是做减法运算，然后将结果的正负保存在标志寄存器中

### 基址寄存器和变址寄存器

基址寄存器的值不变化，而变址寄存器的值变化（相当于数组索引的数值），可以综合使用这两个寄存器来表示数组，比如：

```text
 实际地址 = 基址寄存器的值 + 变址寄存器的值
    ↓           ↓             ↓
10000000  =  10000000  +  00000000
10000001  =            +  00000001
10000002  =            +  00000002
  ....                      ....
1000FFFF  =            +  0000FFFF
```

# 二进制

## 移位运算

- 左移运算，高位溢出丢弃，低位补 `0`

- 右移运算，低位溢出丢弃，高位补 `0` 或 `1`

### 补码

二进制最高位其实是符号位，为 `0` 时表示整数，为 `1` 时表示负数，但是需要注意的是：`1` 是 `00000001`，但 `-1` 并不是 `10000001`，而是 `11111111`

#### 补码的计算

按位取反，再 +1：

```text
-1  ->  00000001  ->  11111110  ->  11111111
```

#### 补码的作用

计算机内的减法运算其实都是用加法运算实现的，这也是使用二进制补码来表示负数的重要原因之一，比如对于运算 `1 - 1`（也就是 `1 + (- 1)`），答案应该为 `0` ；但若用 `10000001` 表示 `-1`，则运算结果为 `10000010`，是不正确的

如果使用补码来表示 -1，即 `11111111`，则运算结果为正确的 `00000000`，最高位的 `1` 溢出舍弃

有一个重要的结论：**二进制按位取反后加 `1` 的结果，与原来的正值相加，结果为 `0`**

因为，按位取反与原数相加，必得 `11111111`，加 `1` 之后，最高位溢出，答案为 `0`

### 逻辑右移和算术右移

#### 逻辑右移

当二进制数的值表示 **图形模式** 而非 **数值** 时，移位后需要在最高位补 0

#### 算术右移

考虑到符号位的存在，移位后需要在高位重新填充符号位的值，这就是算术右移：

`-4` （`11111100`）算术右移之后为 `-1` (`11111111`)，空出来的高位由符号位 `1` 填充

#### 符号扩充

如果将 8 位二进制数转换为 16 位或 32 位等，多出来的高位，依旧用符号位的值填充即可

## 逻辑运算

将二进制数表示的信息作为四则运算的数值来处理，就是 **算术运算**；而单纯像图形一样处理 `0` 和 `1` 的罗列，就是 **逻辑运算**

逻辑运算有四种：非（NOT）、与（AND）、或（OR）、异或（XOR/EOR）

## 二进制小数

二进制小数存在精度问题，因为二进制位只能表示以 1/2、1/4、1/8、1/16 等位权组合而成的小数，这导致很多十进制小数是没办法用有限的二进制小数表示的

```text
0.0000  ->  0
0.0001  ->  0.0625
0.0010  ->  0.125
0.0011  ->  0.1875
...
```

### 浮点数

计算机内部无法直接使用像 `1011.0011` 这样的带小数点的表现形式，通常的编程语言提供了两种表示小数的数据类型：**单精度浮点数** 和 **双精度浮点数**，前者用 32 位，后者用 64 位来表示全体小数

浮点数用 **符号**、**尾数**、**基数** 和 **指数** 这四部分来表示小数：

```text
  ±    m  ×  n   ^   e
  ↓    ↓     ↓       ↓
 符号  尾数  基数     指数
```

其中符号部分占 1 位，指数部分占 8/11 位，尾数部分占 23/52 位（IEEE 规定）

#### 正则表达式和 EXCESS 系统

尾数部分使用 **正则表达式** 来表示，二进制数规定尾数部分一定满足 “**小数点前面的值固定为 1**”，这样我们就可以不保存小数点前面的值了

指数部分使用 **EXCESS 系统** 来表示，因为有可能有负值，因此将所有可以表示的数分为两半，中间为 0，比如单精度浮点数用 `01111111` 表示 0，`10000000` 表示 `1`，`01111110` 表示 `-1`



# 内存

## 内存的物理工作机制

比如对于某个内存 IC，它有数个引脚：

- VCC、GND：电源

- D0 ~ D7：数据信号，一共 8 个引脚，代表一次可以输出 8 位（1 Byte）的数据

- A0 ~ A9：地址信号，一共 10 个引脚，代表可以有 2 ^ 10 个地址，可以存储 2 ^ 10 Byte，即 1 KB 的数据

- RD、WR：控制信号，表示是读数据还是写数据

比如要写数据，WR 为 1，然后通过地址信号指定写入地址，数据信号指定写入值即可

## 内存的逻辑模型

内存就像一幢楼房，每楼代表一个地址，地址是连续的。编程语言通过指定 **数据类型** 来指定占用的楼层数（内存大小）

## 指针

在某些变成语言中会有指针，比如 C。简单的来讲，**指针** 也是一种变量，他存储着数据的内存地址

## 数组

数组是多个同样的数据类型在内存中连续排列的形式，每个元素通过连续的编号（索引）被区分来开，需要注意的是 JS 的数组并不是这种严格意义上的数组

### 栈、队列以及环形缓冲区

栈和队列都可以不通过指定地址和索引来读写数组的元素，其中栈用的是 LIFO 的方式，而队列则是 FIFO

队列一般是以环状缓冲区（ring buffer）的方式来实现的

### 链表

在数组的各个元素中，除了数据的值以外，给其附带上下一个元素的索引，即可实现链表，通过链表可以高效地追加或删除数据

### 二叉树

在链表的基础上往数组增加元素的时候，考虑到数据的大小关系，将其分为左右两个方向，这样可以增加查找的效率

# 磁盘

## 磁盘缓存

磁盘缓存是将磁盘中读取出来的数据存储到内存空间的方式，可以大大提高磁盘数据的访问速度

## 磁盘的物理结构

磁盘将其物理表面划分成多个空间来使用，划分的方式有 **扇区方式** 和 **可变长方式**；前者是固定空间，而后者则将磁盘划分为长度可变的空间

在 Windows 中，一般就采取扇区方式：将磁盘表面分成若干个同心圆的空间（**磁道**），再把磁道按照固定大小划分成（**扇区**）

此外，在 Windows 中，在逻辑层面读写磁盘的单位是扇区的整数倍**簇**，根据磁盘容量不同，1 簇可以是 512 B、1 KB、2 KB 等。**不同的文件是不能存储在同一簇中的**，但需要注意的时候，程序可以在逻辑上以字节为单位对内容进行读写

# 数据压缩

## RLE 算法

简单来说就是将文件内容用 “数据 × 重复次数” 的形式来表示，比如用 `A3B2C9` 表示 `AAABBCCCCCCCCC`

该算法的主要缺点是不适合文本文件的压缩，而比较适合经常连续出现的图像、文件等

## 哈夫曼算法

简单来说就是将出现频率很高的字符用更短的位数来表示（比如小于 8 位），出现频率低的字符用长编码来表示

比如摩尔斯编码就是将在文本中出现频率比较高的字符用短编码来表示，但是需要注意的是文件在存储的时候仍然是以 8 位的字节为单位的

可以用二叉树来实现哈夫曼编码

## 可逆压缩与非可逆压缩

比如对 EXE 文件、文本文件，他们的每个字符、数值都有具体的含义，因此必须要还原到和压缩前同样的内容，因此称为 **可逆压缩**；

而图片压缩之后有一些模糊也可以接受，不必使用同样的算法，有的算法是无法还原到之前相同的内容的，称为 **非可逆压缩**

# 汇编语言

- 汇编语言 = 本地代码（机器语言） + 助记符

  - 汇编语言     --汇编器进行汇编-->    本地代码
  - 汇编语言  <--反汇编程序进行反汇编--  本地代码

# 硬件控制

## IN 与 OUT 指令
Windows 控制硬件借助的是输入和输出指令，比较具有代表性的就是 IN 和 OUT 指令：**IN 指令** 通过指定的端口号输入数据，并存储在 CPU 内部的寄存器中；**OUT 指令** 则把 CPU 寄存器中存储的数据，输出到指定的端口

**I/O 控制器** 用来是用来交换计算机主机通外围设备电流特性的 IC，他内部有用于临时保存输入输出数据的内存（端口）

I/O 端口号是所有的外围设备都必需的

## IRQ

IRQ（Interrupt Request）是 **中断请求**，用来暂停当前正在运行的程序，并跳转到其他程序运行，这种机制被称为 **中断处理**

实施中断请求的是连接外围设备的 I/O 控制器，实施中断处理程序的是 CPU，外围设备的中断请求会使用 **中断编号** 进行标记，操作系统和 BIOS 会提供响应中断编号的中断处理程序

IRQ 只对于需要中断处理的外围设备是必需的

## DMA

DMA（Direct Memory Access）是指在不通过 CPU 的情况下，外围设备直接和主内存进行数据传送。磁盘等通过利用 DMA 可以让大量的数据在短时间内传送到主内存，节省了 CPU 作为中介的时间

DMA 只对于需要 DMA 机制的外围设备是必需的

## 文字及图片的显示机制

显示器中显示的信息一直都存在 VRAM（Video RAM）中，只要往 VRAM 中写入数据，该数据就会在显示器中显示出来——这是由操作系统或者 BIOS 听的，并借助中断来进行处理的

现在的计算机中，显卡等硬件中一般都有与主内存像独立的 VRAM 和 GPU（Graphics Processing Unit）